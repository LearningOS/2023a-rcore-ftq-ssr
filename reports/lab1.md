# Lab1 CH3实验报告

## 实现功能总结
  这次实验的要求是在分时多任务系统中引入一个新的系统调用sys_task_info 以获取当前任务的信息，包括任务状态）、任务使用的系统调用及调用次数
及系统调用时刻距离任务第一次被调度时刻的时长，与之前的sys_get_time等系统调用不同，taskinfo需要得到任务控制快的相关信息  
  首先任务状态我们可以直接在任务管理器中添加一个函数查询当前任务的TaskStatus；然后第二个要求，任务使用的系统调用我们可以可以在任务控制块
中的task_cx里添加一个数组，用于记录各个系统调用，为了节省空间，使用各个系统重新编号的序号，并添加一个函数用于获取当时的各个系统调用次数，
至于更新系统调用次数就放在入内核态系统调用异常处理函数之后，进入具体系统调用函数之前维护；最后一个要求我选择在run_first_task与run_next_task
处记录，同时判断是否是第一次修改，然后在需要时获取这个值就可以了。
## 简答作业
1. 无报错，sbi版本：RustSBI version 0.3.0-alpha.
2. 第二题
    1. 刚进入__restore时，a0代表的是内核栈，两种用法分别是trap后恢复上下文和在开始是初始化各个寄存器状态
    2. 特殊处理了sstatus,sepc与sscratch,其中sstatus用于记录Trap 发生之前 CPU 处在哪个特权级（S/U）等信息；sepc当 Trap 是一个异常的时候，
记录 Trap 发生之前执行的最后一条指令的地址；sscratch用于trap开始与恢复时转换sp位置
    3. x4寄存器，除非我们手动出于一些特殊用途使用它，否则一般也不会被用到；x2在alltrap时没有保存，因为在这里也不保存 sp(x2)，因为它在第 9 行 后指向的是内核栈。
用户栈的栈指针保存在 sscratch 中，必须通过 csrr 指令读到通用寄存器中后才能使用。
    4. sp值指向用户栈，sscrath指向内核栈
    5. 最后一行的sret指令，因为sret是一条 S 特权级的特权指令 ，这一条指令具体完成以下功能：
       - CPU 会将当前的特权级按照 sstatus 的 SPP 字段设置为 U 或者 S ；
       - CPU 会跳转到 sepc 寄存器指向的那条指令，然后继续执行。
    6. sp值指向内核栈，sscrath指向用户栈
    7. 从U态进入S态是由ecall发生的
## 荣誉准则

1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了
具体的交流对象及内容：

    -《你交流的对象说明》 无

2. 此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

    -《你参考的资料说明》  仅参考了v3的书

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥
善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，
对应的实验成绩将按“-100”分计。
